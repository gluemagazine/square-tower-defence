[gd_scene load_steps=39 format=3 uid="uid://5mm5n1pdtdty"]

[ext_resource type="Script" uid="uid://dvurxwnsxq214" path="res://resources/animations/scripts/animation_builder.gd" id="1_dctvm"]
[ext_resource type="Script" uid="uid://chm5b7j15jddi" path="res://resources/animations/scripts/animated_panel.gd" id="1_ktjvc"]
[ext_resource type="Script" uid="uid://dqusptgsgmn34" path="res://resources/animations/scripts/panel_animations_container.gd" id="2_lg3kb"]
[ext_resource type="Resource" uid="uid://cfgarteaew7vs" path="res://resources/animations/random stuff/star with purple thing1.tres" id="3_d3rcj"]
[ext_resource type="Script" uid="uid://bttbxankdbyq" path="res://resources/animations/scripts/panel_animation.gd" id="4_5ropb"]
[ext_resource type="Resource" uid="uid://dcphxfx2nnwyg" path="res://resources/animations/random stuff/star with purple thing2.tres" id="4_81k0h"]
[ext_resource type="Script" uid="uid://57bm4bwb17hy" path="res://resources/animations/scripts/property_animation.gd" id="5_qdivu"]
[ext_resource type="Resource" uid="uid://ofh40ay1q3gc" path="res://resources/animations/random stuff/star with purple thing3.tres" id="5_wecuw"]
[ext_resource type="Resource" uid="uid://cxyyf36ootb61" path="res://resources/animations/random stuff/star with purple thing4.tres" id="6_l1i5v"]
[ext_resource type="Resource" uid="uid://bpas0a87vke8n" path="res://resources/animations/spin.tres" id="10_lg3kb"]

[sub_resource type="Shader" id="Shader_d3rcj"]
code = "shader_type canvas_item;

// courtesy of cashew-olddew, shown in a youtube video, very nice shader

uniform bool use_sprite_alpha = true;
uniform bool use_transition_texture = false;
uniform sampler2D transition_texture;
uniform int transition_type: hint_enum(\"Basic\", \"Mask\", \"Shape\", \"Clock\") = 0;

group_uniforms positioning;
uniform vec2 position = vec2(0,0);
uniform bool invert = false;
uniform vec2 grid_size = vec2(1.0, 1.0);
uniform float rotation_angle = 0.0;

group_uniforms positioning.stagger;
uniform vec2 stagger = vec2(0.0, 0.0);
uniform ivec2 stagger_frequency = ivec2(2, 2);
uniform ivec2 flip_frequency = ivec2(1, 1);

group_uniforms basic_transition_controls;
uniform float basic_feather = 0.0;

group_uniforms mask_transition_controls;
uniform sampler2D mask_texture;
uniform bool use_mask_size = false;
uniform vec2 mask_size = vec2(100.0);

group_uniforms shape_transition_controls;
uniform int edges : hint_range(3, 64) = 6; // default hexagon
uniform float shape_feather : hint_range(0.0, 10.0) = 0.1;

group_uniforms clock_transition_controls;
uniform int sectors : hint_range(1, 128) = 1;
uniform float clock_feather : hint_range(0.0, 16.0) = 0.0;

group_uniforms animation;
uniform float progress = 0.0;
uniform vec2 progress_bias = vec2(0.0);

varying vec4 modulate;

vec2 use_actual_texture_size(vec2 uv, vec2 texture_size) {

	uv -= 0.5;
	vec2 uv_deriv = fwidth(uv);
	float screen_ratio = uv_deriv.x / uv_deriv.y;
	float texture_ratio = texture_size.x / texture_size.y;
	float mixed_ratio = texture_ratio * screen_ratio;

	if (screen_ratio > texture_ratio) {
		uv.x /= mixed_ratio;
	} else {
		uv.y *= mixed_ratio;
	}

	return uv + 0.5;
}

vec2 get_stagger_offset(vec2 grid) {
	vec2 cells = floor(grid);
	float offset_row = mod(cells.y, float(stagger_frequency.x)) == 0.0 ? 0.5 : 0.0;
	float offset_col = mod(cells.x, float(stagger_frequency.y)) == 0.0 ? 0.5 : 0.0;

	return vec2(
		offset_row * stagger.x,
		offset_col * stagger.y
	);
}

vec2 get_grid_flip(vec2 grid) {
	vec2 cells = floor(grid);
	float flip_row = mod(cells.y, float(flip_frequency.x)) == 0.0 ? 1.0 : -1.0;
	float flip_col = mod(cells.x, float(flip_frequency.y)) == 0.0 ? 1.0 : -1.0;

	return vec2(
		flip_row * grid.x,
		flip_col * grid.y
	);
}

vec2 rotate(vec2 v, float angle) {
	return mat2(
		vec2(cos(angle), sin(angle)),
		vec2(-sin(angle), cos(angle))
		) * v;
}

vec2 get_edges(float center, float width) {
	float half_width = width * 0.5;
	float edge0 = center - half_width;
	float edge1 = center + half_width + 1e-5;
	return vec2(edge0, edge1);
}

float get_local_progress(vec2 grid) {
    vec2 cell = floor(grid);
	// Easier to control bias values
	vec2 pretty_bias = progress_bias / 10.0;
    float offset = dot(cell, pretty_bias);
    return progress - offset;
}

void vertex() {
	modulate = COLOR;
}

void fragment() {
	vec2 grid = UV * grid_size;
	vec2 offset_uv = grid + get_stagger_offset(grid);
	vec2 grid_flipped_uv = get_grid_flip(offset_uv);
	vec2 tiled_uv = fract(grid_flipped_uv);
	vec2 uv = (tiled_uv - position) * 2.0;
	uv = rotate(uv, radians(rotation_angle));

	float local_progress = get_local_progress(grid);

	COLOR = texture(TEXTURE, UV) * modulate;
	float alpha = COLOR.a;
	float transition_progress = 0.0;

	if (transition_type == 1) {
		vec2 mask_zoom_uv = uv / local_progress;
		vec2 mask_zoom_uv_01 = mask_zoom_uv * 0.5 + 0.5;
		mask_zoom_uv_01 = use_mask_size ? use_actual_texture_size(mask_zoom_uv_01, mask_size) : mask_zoom_uv_01;

		transition_progress = texture(mask_texture, mask_zoom_uv_01).r;

	} else if(transition_type == 2) {
    	float radius = length(uv);
	    float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(edges);
		float half_sector = sector_angle / 2.0;
		// Define polygon sectors using the power of trigonometry
		float d = cos(half_sector) / cos(mod(angle + half_sector, sector_angle) - half_sector);

		vec2 smooth_edges = get_edges(local_progress, shape_feather);
		transition_progress = smoothstep(smooth_edges.x, smooth_edges.y, radius / d);

	} else if (transition_type == 3) {
		float radius = length(uv);
		float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(sectors);
		float half_sector = sector_angle / 2.0;
		angle = mod(angle - half_sector, sector_angle);

		float progress_angle = local_progress * 2.0 * PI / float(sectors);
		float smooth_angle = smoothstep(0.0, clock_feather, progress_angle - angle);
		transition_progress = smooth_angle;

	} else {
		vec2 smooth_edges = get_edges(local_progress, basic_feather);

		float separation_x = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.x));
		float separation_y = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.y));
		transition_progress = max(separation_x, separation_y);
	}

	alpha = invert ? 1.0 - transition_progress : transition_progress;
	alpha = use_sprite_alpha ? min(COLOR.a, alpha) : alpha;

	vec4 transition_color = texture(transition_texture, UV);

	if (use_transition_texture) {
		vec4 chosen_color = mix(transition_color, COLOR, alpha);
		COLOR = chosen_color;
	} else {
		COLOR.a = alpha;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_lg3kb"]
shader = SubResource("Shader_d3rcj")
shader_parameter/use_sprite_alpha = true
shader_parameter/use_transition_texture = false
shader_parameter/transition_type = 2
shader_parameter/position = Vector2(0.5, 0.5)
shader_parameter/invert = true
shader_parameter/grid_size = Vector2(1, 1)
shader_parameter/rotation_angle = 0.0
shader_parameter/stagger = Vector2(0, 0)
shader_parameter/stagger_frequency = Vector2i(2, 2)
shader_parameter/flip_frequency = Vector2i(1, 1)
shader_parameter/basic_feather = 0.0
shader_parameter/use_mask_size = false
shader_parameter/mask_size = Vector2(100, 100)
shader_parameter/edges = 6
shader_parameter/shape_feather = 0.0
shader_parameter/sectors = 1
shader_parameter/clock_feather = 0.0
shader_parameter/progress = 1.0
shader_parameter/progress_bias = Vector2(0, 0)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_d3rcj"]
bg_color = Color(0, 1, 0, 1)

[sub_resource type="Resource" id="Resource_l1i5v"]
script = ExtResource("5_qdivu")
property = "color"
from_default = false
invert_on_flip = true
number_animated = false
initial_value = 0.0
final_value = 0.0
initial_color = Color(1, 1, 1, 1)
final_color = Color(0, 1, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_xb0la"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = true
number_animated = true
initial_value = 0.0
final_value = 360.0
initial_color = Color(0, 0, 0, 1)
final_color = Color(0, 0, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_ugsxj"]
script = ExtResource("5_qdivu")
property = "color"
from_default = false
invert_on_flip = true
number_animated = false
initial_value = 0.0
final_value = 0.0
initial_color = Color(0, 1, 0, 1)
final_color = Color(1, 1, 1, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_xx4m5"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = true
number_animated = true
initial_value = 0.0
final_value = 360.0
initial_color = Color(0, 0, 0, 1)
final_color = Color(0, 0, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_4rr8g"]
script = ExtResource("4_5ropb")
animation_name = "shift"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([SubResource("Resource_ugsxj"), SubResource("Resource_xx4m5")])
played = false
on_secondary = false
mirror_animation = false
metadata/_custom_type_script = "uid://bttbxankdbyq"

[sub_resource type="Resource" id="Resource_6bx5l"]
script = ExtResource("4_5ropb")
animation_name = "shift"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([SubResource("Resource_l1i5v"), SubResource("Resource_xb0la")])
played = false
on_secondary = false
mirror_animation = false
secondary_animation = SubResource("Resource_4rr8g")

[sub_resource type="Shader" id="Shader_57udo"]
code = "shader_type canvas_item;

// courtesy of cashew-olddew, shown in a youtube video, very nice shader

uniform bool use_sprite_alpha = true;
uniform bool use_transition_texture = false;
uniform sampler2D transition_texture;
uniform int transition_type: hint_enum(\"Basic\", \"Mask\", \"Shape\", \"Clock\") = 0;

group_uniforms positioning;
uniform vec2 position = vec2(0,0);
uniform bool invert = false;
uniform vec2 grid_size = vec2(1.0, 1.0);
uniform float rotation_angle = 0.0;

group_uniforms positioning.stagger;
uniform vec2 stagger = vec2(0.0, 0.0);
uniform ivec2 stagger_frequency = ivec2(2, 2);
uniform ivec2 flip_frequency = ivec2(1, 1);

group_uniforms basic_transition_controls;
uniform float basic_feather = 0.0;

group_uniforms mask_transition_controls;
uniform sampler2D mask_texture;
uniform bool use_mask_size = false;
uniform vec2 mask_size = vec2(100.0);

group_uniforms shape_transition_controls;
uniform int edges : hint_range(3, 64) = 6; // default hexagon
uniform float shape_feather : hint_range(0.0, 10.0) = 0.1;

group_uniforms clock_transition_controls;
uniform int sectors : hint_range(1, 128) = 1;
uniform float clock_feather : hint_range(0.0, 16.0) = 0.0;

group_uniforms animation;
uniform float progress = 0.0;
uniform vec2 progress_bias = vec2(0.0);

varying vec4 modulate;

vec2 use_actual_texture_size(vec2 uv, vec2 texture_size) {

	uv -= 0.5;
	vec2 uv_deriv = fwidth(uv);
	float screen_ratio = uv_deriv.x / uv_deriv.y;
	float texture_ratio = texture_size.x / texture_size.y;
	float mixed_ratio = texture_ratio * screen_ratio;

	if (screen_ratio > texture_ratio) {
		uv.x /= mixed_ratio;
	} else {
		uv.y *= mixed_ratio;
	}

	return uv + 0.5;
}

vec2 get_stagger_offset(vec2 grid) {
	vec2 cells = floor(grid);
	float offset_row = mod(cells.y, float(stagger_frequency.x)) == 0.0 ? 0.5 : 0.0;
	float offset_col = mod(cells.x, float(stagger_frequency.y)) == 0.0 ? 0.5 : 0.0;

	return vec2(
		offset_row * stagger.x,
		offset_col * stagger.y
	);
}

vec2 get_grid_flip(vec2 grid) {
	vec2 cells = floor(grid);
	float flip_row = mod(cells.y, float(flip_frequency.x)) == 0.0 ? 1.0 : -1.0;
	float flip_col = mod(cells.x, float(flip_frequency.y)) == 0.0 ? 1.0 : -1.0;

	return vec2(
		flip_row * grid.x,
		flip_col * grid.y
	);
}

vec2 rotate(vec2 v, float angle) {
	return mat2(
		vec2(cos(angle), sin(angle)),
		vec2(-sin(angle), cos(angle))
		) * v;
}

vec2 get_edges(float center, float width) {
	float half_width = width * 0.5;
	float edge0 = center - half_width;
	float edge1 = center + half_width + 1e-5;
	return vec2(edge0, edge1);
}

float get_local_progress(vec2 grid) {
    vec2 cell = floor(grid);
	// Easier to control bias values
	vec2 pretty_bias = progress_bias / 10.0;
    float offset = dot(cell, pretty_bias);
    return progress - offset;
}

void vertex() {
	modulate = COLOR;
}

void fragment() {
	vec2 grid = UV * grid_size;
	vec2 offset_uv = grid + get_stagger_offset(grid);
	vec2 grid_flipped_uv = get_grid_flip(offset_uv);
	vec2 tiled_uv = fract(grid_flipped_uv);
	vec2 uv = (tiled_uv - position) * 2.0;
	uv = rotate(uv, radians(rotation_angle));

	float local_progress = get_local_progress(grid);

	COLOR = texture(TEXTURE, UV) * modulate;
	float alpha = COLOR.a;
	float transition_progress = 0.0;

	if (transition_type == 1) {
		vec2 mask_zoom_uv = uv / local_progress;
		vec2 mask_zoom_uv_01 = mask_zoom_uv * 0.5 + 0.5;
		mask_zoom_uv_01 = use_mask_size ? use_actual_texture_size(mask_zoom_uv_01, mask_size) : mask_zoom_uv_01;

		transition_progress = texture(mask_texture, mask_zoom_uv_01).r;

	} else if(transition_type == 2) {
    	float radius = length(uv);
	    float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(edges);
		float half_sector = sector_angle / 2.0;
		// Define polygon sectors using the power of trigonometry
		float d = cos(half_sector) / cos(mod(angle + half_sector, sector_angle) - half_sector);

		vec2 smooth_edges = get_edges(local_progress, shape_feather);
		transition_progress = smoothstep(smooth_edges.x, smooth_edges.y, radius / d);

	} else if (transition_type == 3) {
		float radius = length(uv);
		float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(sectors);
		float half_sector = sector_angle / 2.0;
		angle = mod(angle - half_sector, sector_angle);

		float progress_angle = local_progress * 2.0 * PI / float(sectors);
		float smooth_angle = smoothstep(0.0, clock_feather, progress_angle - angle);
		transition_progress = smooth_angle;

	} else {
		vec2 smooth_edges = get_edges(local_progress, basic_feather);

		float separation_x = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.x));
		float separation_y = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.y));
		transition_progress = max(separation_x, separation_y);
	}

	alpha = invert ? 1.0 - transition_progress : transition_progress;
	alpha = use_sprite_alpha ? min(COLOR.a, alpha) : alpha;

	vec4 transition_color = texture(transition_texture, UV);

	if (use_transition_texture) {
		vec4 chosen_color = mix(transition_color, COLOR, alpha);
		COLOR = chosen_color;
	} else {
		COLOR.a = alpha;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_57udo"]
shader = SubResource("Shader_57udo")
shader_parameter/use_sprite_alpha = true
shader_parameter/use_transition_texture = false
shader_parameter/transition_type = 2
shader_parameter/position = Vector2(0.5, 0.5)
shader_parameter/invert = true
shader_parameter/grid_size = Vector2(1, 1)
shader_parameter/rotation_angle = 0.0
shader_parameter/stagger = Vector2(0, 0)
shader_parameter/stagger_frequency = Vector2i(2, 2)
shader_parameter/flip_frequency = Vector2i(1, 1)
shader_parameter/basic_feather = 0.0
shader_parameter/use_mask_size = false
shader_parameter/mask_size = Vector2(100, 100)
shader_parameter/edges = 4
shader_parameter/shape_feather = 0.0
shader_parameter/sectors = 1
shader_parameter/clock_feather = 0.0
shader_parameter/progress = 1.0
shader_parameter/progress_bias = Vector2(0, 0)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_pf1yj"]
bg_color = Color(1, 0, 0, 1)

[sub_resource type="Resource" id="Resource_m5ccf"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = false
number_animated = true
initial_value = 0.0
final_value = 360.0
initial_color = Color(0, 0, 0, 1)
final_color = Color(0, 0, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_d057m"]
script = ExtResource("5_qdivu")
property = "color"
from_default = false
invert_on_flip = true
number_animated = false
initial_value = 0.0
final_value = 0.0
initial_color = Color(1, 0, 0, 1)
final_color = Color(1, 1, 1, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_uci2g"]
script = ExtResource("4_5ropb")
animation_name = "walk"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([SubResource("Resource_m5ccf"), SubResource("Resource_d057m")])
played = false
on_secondary = false
mirror_animation = false

[sub_resource type="Shader" id="Shader_cjq17"]
code = "shader_type canvas_item;

// courtesy of cashew-olddew, shown in a youtube video, very nice shader

uniform bool use_sprite_alpha = true;
uniform bool use_transition_texture = false;
uniform sampler2D transition_texture;
uniform int transition_type: hint_enum(\"Basic\", \"Mask\", \"Shape\", \"Clock\") = 0;

group_uniforms positioning;
uniform vec2 position = vec2(0,0);
uniform bool invert = false;
uniform vec2 grid_size = vec2(1.0, 1.0);
uniform float rotation_angle = 0.0;

group_uniforms positioning.stagger;
uniform vec2 stagger = vec2(0.0, 0.0);
uniform ivec2 stagger_frequency = ivec2(2, 2);
uniform ivec2 flip_frequency = ivec2(1, 1);

group_uniforms basic_transition_controls;
uniform float basic_feather = 0.0;

group_uniforms mask_transition_controls;
uniform sampler2D mask_texture;
uniform bool use_mask_size = false;
uniform vec2 mask_size = vec2(100.0);

group_uniforms shape_transition_controls;
uniform int edges : hint_range(3, 64) = 6; // default hexagon
uniform float shape_feather : hint_range(0.0, 10.0) = 0.1;

group_uniforms clock_transition_controls;
uniform int sectors : hint_range(1, 128) = 1;
uniform float clock_feather : hint_range(0.0, 16.0) = 0.0;

group_uniforms animation;
uniform float progress = 0.0;
uniform vec2 progress_bias = vec2(0.0);

varying vec4 modulate;

vec2 use_actual_texture_size(vec2 uv, vec2 texture_size) {

	uv -= 0.5;
	vec2 uv_deriv = fwidth(uv);
	float screen_ratio = uv_deriv.x / uv_deriv.y;
	float texture_ratio = texture_size.x / texture_size.y;
	float mixed_ratio = texture_ratio * screen_ratio;

	if (screen_ratio > texture_ratio) {
		uv.x /= mixed_ratio;
	} else {
		uv.y *= mixed_ratio;
	}

	return uv + 0.5;
}

vec2 get_stagger_offset(vec2 grid) {
	vec2 cells = floor(grid);
	float offset_row = mod(cells.y, float(stagger_frequency.x)) == 0.0 ? 0.5 : 0.0;
	float offset_col = mod(cells.x, float(stagger_frequency.y)) == 0.0 ? 0.5 : 0.0;

	return vec2(
		offset_row * stagger.x,
		offset_col * stagger.y
	);
}

vec2 get_grid_flip(vec2 grid) {
	vec2 cells = floor(grid);
	float flip_row = mod(cells.y, float(flip_frequency.x)) == 0.0 ? 1.0 : -1.0;
	float flip_col = mod(cells.x, float(flip_frequency.y)) == 0.0 ? 1.0 : -1.0;

	return vec2(
		flip_row * grid.x,
		flip_col * grid.y
	);
}

vec2 rotate(vec2 v, float angle) {
	return mat2(
		vec2(cos(angle), sin(angle)),
		vec2(-sin(angle), cos(angle))
		) * v;
}

vec2 get_edges(float center, float width) {
	float half_width = width * 0.5;
	float edge0 = center - half_width;
	float edge1 = center + half_width + 1e-5;
	return vec2(edge0, edge1);
}

float get_local_progress(vec2 grid) {
    vec2 cell = floor(grid);
	// Easier to control bias values
	vec2 pretty_bias = progress_bias / 10.0;
    float offset = dot(cell, pretty_bias);
    return progress - offset;
}

void vertex() {
	modulate = COLOR;
}

void fragment() {
	vec2 grid = UV * grid_size;
	vec2 offset_uv = grid + get_stagger_offset(grid);
	vec2 grid_flipped_uv = get_grid_flip(offset_uv);
	vec2 tiled_uv = fract(grid_flipped_uv);
	vec2 uv = (tiled_uv - position) * 2.0;
	uv = rotate(uv, radians(rotation_angle));

	float local_progress = get_local_progress(grid);

	COLOR = texture(TEXTURE, UV) * modulate;
	float alpha = COLOR.a;
	float transition_progress = 0.0;

	if (transition_type == 1) {
		vec2 mask_zoom_uv = uv / local_progress;
		vec2 mask_zoom_uv_01 = mask_zoom_uv * 0.5 + 0.5;
		mask_zoom_uv_01 = use_mask_size ? use_actual_texture_size(mask_zoom_uv_01, mask_size) : mask_zoom_uv_01;

		transition_progress = texture(mask_texture, mask_zoom_uv_01).r;

	} else if(transition_type == 2) {
    	float radius = length(uv);
	    float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(edges);
		float half_sector = sector_angle / 2.0;
		// Define polygon sectors using the power of trigonometry
		float d = cos(half_sector) / cos(mod(angle + half_sector, sector_angle) - half_sector);

		vec2 smooth_edges = get_edges(local_progress, shape_feather);
		transition_progress = smoothstep(smooth_edges.x, smooth_edges.y, radius / d);

	} else if (transition_type == 3) {
		float radius = length(uv);
		float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(sectors);
		float half_sector = sector_angle / 2.0;
		angle = mod(angle - half_sector, sector_angle);

		float progress_angle = local_progress * 2.0 * PI / float(sectors);
		float smooth_angle = smoothstep(0.0, clock_feather, progress_angle - angle);
		transition_progress = smooth_angle;

	} else {
		vec2 smooth_edges = get_edges(local_progress, basic_feather);

		float separation_x = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.x));
		float separation_y = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.y));
		transition_progress = max(separation_x, separation_y);
	}

	alpha = invert ? 1.0 - transition_progress : transition_progress;
	alpha = use_sprite_alpha ? min(COLOR.a, alpha) : alpha;

	vec4 transition_color = texture(transition_texture, UV);

	if (use_transition_texture) {
		vec4 chosen_color = mix(transition_color, COLOR, alpha);
		COLOR = chosen_color;
	} else {
		COLOR.a = alpha;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_jw3cb"]
shader = SubResource("Shader_cjq17")
shader_parameter/use_sprite_alpha = true
shader_parameter/use_transition_texture = false
shader_parameter/transition_type = 2
shader_parameter/position = Vector2(0.5, 0.5)
shader_parameter/invert = true
shader_parameter/grid_size = Vector2(1, 1)
shader_parameter/rotation_angle = 0.0
shader_parameter/stagger = Vector2(0, 0)
shader_parameter/stagger_frequency = Vector2i(2, 2)
shader_parameter/flip_frequency = Vector2i(1, 1)
shader_parameter/basic_feather = 0.0
shader_parameter/use_mask_size = false
shader_parameter/mask_size = Vector2(100, 100)
shader_parameter/edges = 4
shader_parameter/shape_feather = 0.0
shader_parameter/sectors = 1
shader_parameter/clock_feather = 0.0
shader_parameter/progress = 1.0
shader_parameter/progress_bias = Vector2(0, 0)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_cjq17"]
bg_color = Color(0, 0, 1, 1)

[sub_resource type="Resource" id="Resource_1bxkr"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = true
invert_on_flip = true
number_animated = true
initial_value = 0.0
final_value = 360.0
initial_color = Color(0, 0, 0, 1)
final_color = Color(0, 0, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_rh5vn"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = true
number_animated = false
initial_value = 0.0
final_value = 0.0
initial_color = Color(0, 0, 1, 1)
final_color = Color(1, 1, 1, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_wecuw"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = true
number_animated = false
initial_value = 0.0
final_value = 0.0
initial_color = Color(1, 1, 1, 1)
final_color = Color(0, 0, 1, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_17sgk"]
script = ExtResource("4_5ropb")
animation_name = "walk"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([ExtResource("10_lg3kb"), SubResource("Resource_wecuw")])
played = false
on_secondary = false
mirror_animation = false
metadata/_custom_type_script = "uid://bttbxankdbyq"

[sub_resource type="Resource" id="Resource_o1tfi"]
script = ExtResource("4_5ropb")
animation_name = "walk"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([SubResource("Resource_1bxkr"), SubResource("Resource_rh5vn")])
played = false
on_secondary = false
mirror_animation = false
secondary_animation = SubResource("Resource_17sgk")

[sub_resource type="Shader" id="Shader_aabqq"]
code = "shader_type canvas_item;

// courtesy of cashew-olddew, shown in a youtube video, very nice shader

uniform bool use_sprite_alpha = true;
uniform bool use_transition_texture = false;
uniform sampler2D transition_texture;
uniform int transition_type: hint_enum(\"Basic\", \"Mask\", \"Shape\", \"Clock\") = 0;

group_uniforms positioning;
uniform vec2 position = vec2(0,0);
uniform bool invert = false;
uniform vec2 grid_size = vec2(1.0, 1.0);
uniform float rotation_angle = 0.0;

group_uniforms positioning.stagger;
uniform vec2 stagger = vec2(0.0, 0.0);
uniform ivec2 stagger_frequency = ivec2(2, 2);
uniform ivec2 flip_frequency = ivec2(1, 1);

group_uniforms basic_transition_controls;
uniform float basic_feather = 0.0;

group_uniforms mask_transition_controls;
uniform sampler2D mask_texture;
uniform bool use_mask_size = false;
uniform vec2 mask_size = vec2(100.0);

group_uniforms shape_transition_controls;
uniform int edges : hint_range(3, 64) = 6; // default hexagon
uniform float shape_feather : hint_range(0.0, 10.0) = 0.1;

group_uniforms clock_transition_controls;
uniform int sectors : hint_range(1, 128) = 1;
uniform float clock_feather : hint_range(0.0, 16.0) = 0.0;

group_uniforms animation;
uniform float progress = 0.0;
uniform vec2 progress_bias = vec2(0.0);

varying vec4 modulate;

vec2 use_actual_texture_size(vec2 uv, vec2 texture_size) {

	uv -= 0.5;
	vec2 uv_deriv = fwidth(uv);
	float screen_ratio = uv_deriv.x / uv_deriv.y;
	float texture_ratio = texture_size.x / texture_size.y;
	float mixed_ratio = texture_ratio * screen_ratio;

	if (screen_ratio > texture_ratio) {
		uv.x /= mixed_ratio;
	} else {
		uv.y *= mixed_ratio;
	}

	return uv + 0.5;
}

vec2 get_stagger_offset(vec2 grid) {
	vec2 cells = floor(grid);
	float offset_row = mod(cells.y, float(stagger_frequency.x)) == 0.0 ? 0.5 : 0.0;
	float offset_col = mod(cells.x, float(stagger_frequency.y)) == 0.0 ? 0.5 : 0.0;

	return vec2(
		offset_row * stagger.x,
		offset_col * stagger.y
	);
}

vec2 get_grid_flip(vec2 grid) {
	vec2 cells = floor(grid);
	float flip_row = mod(cells.y, float(flip_frequency.x)) == 0.0 ? 1.0 : -1.0;
	float flip_col = mod(cells.x, float(flip_frequency.y)) == 0.0 ? 1.0 : -1.0;

	return vec2(
		flip_row * grid.x,
		flip_col * grid.y
	);
}

vec2 rotate(vec2 v, float angle) {
	return mat2(
		vec2(cos(angle), sin(angle)),
		vec2(-sin(angle), cos(angle))
		) * v;
}

vec2 get_edges(float center, float width) {
	float half_width = width * 0.5;
	float edge0 = center - half_width;
	float edge1 = center + half_width + 1e-5;
	return vec2(edge0, edge1);
}

float get_local_progress(vec2 grid) {
    vec2 cell = floor(grid);
	// Easier to control bias values
	vec2 pretty_bias = progress_bias / 10.0;
    float offset = dot(cell, pretty_bias);
    return progress - offset;
}

void vertex() {
	modulate = COLOR;
}

void fragment() {
	vec2 grid = UV * grid_size;
	vec2 offset_uv = grid + get_stagger_offset(grid);
	vec2 grid_flipped_uv = get_grid_flip(offset_uv);
	vec2 tiled_uv = fract(grid_flipped_uv);
	vec2 uv = (tiled_uv - position) * 2.0;
	uv = rotate(uv, radians(rotation_angle));

	float local_progress = get_local_progress(grid);

	COLOR = texture(TEXTURE, UV) * modulate;
	float alpha = COLOR.a;
	float transition_progress = 0.0;

	if (transition_type == 1) {
		vec2 mask_zoom_uv = uv / local_progress;
		vec2 mask_zoom_uv_01 = mask_zoom_uv * 0.5 + 0.5;
		mask_zoom_uv_01 = use_mask_size ? use_actual_texture_size(mask_zoom_uv_01, mask_size) : mask_zoom_uv_01;

		transition_progress = texture(mask_texture, mask_zoom_uv_01).r;

	} else if(transition_type == 2) {
    	float radius = length(uv);
	    float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(edges);
		float half_sector = sector_angle / 2.0;
		// Define polygon sectors using the power of trigonometry
		float d = cos(half_sector) / cos(mod(angle + half_sector, sector_angle) - half_sector);

		vec2 smooth_edges = get_edges(local_progress, shape_feather);
		transition_progress = smoothstep(smooth_edges.x, smooth_edges.y, radius / d);

	} else if (transition_type == 3) {
		float radius = length(uv);
		float angle = atan(uv.y, uv.x);
		float sector_angle = 2.0 * PI / float(sectors);
		float half_sector = sector_angle / 2.0;
		angle = mod(angle - half_sector, sector_angle);

		float progress_angle = local_progress * 2.0 * PI / float(sectors);
		float smooth_angle = smoothstep(0.0, clock_feather, progress_angle - angle);
		transition_progress = smooth_angle;

	} else {
		vec2 smooth_edges = get_edges(local_progress, basic_feather);

		float separation_x = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.x));
		float separation_y = smoothstep(smooth_edges.x, smooth_edges.y, abs(uv.y));
		transition_progress = max(separation_x, separation_y);
	}

	alpha = invert ? 1.0 - transition_progress : transition_progress;
	alpha = use_sprite_alpha ? min(COLOR.a, alpha) : alpha;

	vec4 transition_color = texture(transition_texture, UV);

	if (use_transition_texture) {
		vec4 chosen_color = mix(transition_color, COLOR, alpha);
		COLOR = chosen_color;
	} else {
		COLOR.a = alpha;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_dqdnl"]
shader = SubResource("Shader_aabqq")
shader_parameter/use_sprite_alpha = true
shader_parameter/use_transition_texture = false
shader_parameter/transition_type = 2
shader_parameter/position = Vector2(0.5, 0.5)
shader_parameter/invert = true
shader_parameter/grid_size = Vector2(1, 1)
shader_parameter/rotation_angle = 0.0
shader_parameter/stagger = Vector2(0, 0)
shader_parameter/stagger_frequency = Vector2i(2, 2)
shader_parameter/flip_frequency = Vector2i(1, 1)
shader_parameter/basic_feather = 0.0
shader_parameter/use_mask_size = false
shader_parameter/mask_size = Vector2(100, 100)
shader_parameter/edges = 4
shader_parameter/shape_feather = 0.0
shader_parameter/sectors = 1
shader_parameter/clock_feather = 0.0
shader_parameter/progress = 1.0
shader_parameter/progress_bias = Vector2(0, 0)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_fq0np"]
bg_color = Color(1, 0, 1, 1)

[sub_resource type="Resource" id="Resource_aabqq"]
script = ExtResource("5_qdivu")
property = "rotation_angle"
from_default = false
invert_on_flip = false
number_animated = true
initial_value = 0.0
final_value = 360.0
initial_color = Color(0, 0, 0, 1)
final_color = Color(0, 0, 0, 1)
start = 0.0
end = 2.0
metadata/_custom_type_script = "uid://57bm4bwb17hy"

[sub_resource type="Resource" id="Resource_n8xfu"]
script = ExtResource("4_5ropb")
animation_name = "walk"
duration = 2.0
loop = true
properties = Array[ExtResource("5_qdivu")]([SubResource("Resource_aabqq")])
played = false
on_secondary = false
mirror_animation = false

[node name="AnimationBuilder" type="Node2D" node_paths=PackedStringArray("panels")]
script = ExtResource("1_dctvm")
path = "res://resources/animations/towers/archer/"
resource_name = "teal"
panels_to_load = Array[ExtResource("2_lg3kb")]([ExtResource("3_d3rcj"), ExtResource("4_81k0h"), ExtResource("5_wecuw"), ExtResource("6_l1i5v")])
panels = [NodePath("panel"), NodePath("panel2"), NodePath("panel3"), NodePath("panel4")]

[node name="Camera2D" type="Camera2D" parent="."]
zoom = Vector2(2, 2)

[node name="panel" type="Panel" parent="."]
material = SubResource("ShaderMaterial_lg3kb")
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
pivot_offset = Vector2(20, 20)
theme_override_styles/panel = SubResource("StyleBoxFlat_d3rcj")
script = ExtResource("1_ktjvc")
starting_values = Dictionary[String, Variant]({
"edges": 6,
"position": Vector2(0.5, 0.5),
"progress": 1.0,
"rotation_angle": 0.0,
"rotation_degrees": 0.0,
"shape_feather": 0.0
})
color = Color(0, 1, 0, 1)
animation_resources = Array[ExtResource("4_5ropb")]([SubResource("Resource_6bx5l")])
starting_material = SubResource("ShaderMaterial_lg3kb")

[node name="panel2" type="Panel" parent="."]
material = SubResource("ShaderMaterial_57udo")
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
rotation = 0.523599
pivot_offset = Vector2(20, 20)
theme_override_styles/panel = SubResource("StyleBoxFlat_pf1yj")
script = ExtResource("1_ktjvc")
starting_values = Dictionary[String, Variant]({
"edges": 4,
"position": Vector2(0.5, 0.5),
"progress": 1.0,
"rotation_angle": 0.0,
"rotation_degrees": 30.0,
"shape_feather": 0.0
})
color = Color(1, 0, 0, 1)
animation_resources = Array[ExtResource("4_5ropb")]([SubResource("Resource_uci2g")])
starting_material = SubResource("ShaderMaterial_57udo")

[node name="panel3" type="Panel" parent="."]
material = SubResource("ShaderMaterial_jw3cb")
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
rotation = 1.0472
pivot_offset = Vector2(20, 20)
theme_override_styles/panel = SubResource("StyleBoxFlat_cjq17")
script = ExtResource("1_ktjvc")
starting_values = Dictionary[String, Variant]({
"edges": 4,
"position": Vector2(0.5, 0.5),
"progress": 1.0,
"rotation_angle": 0.0,
"rotation_degrees": 60.0,
"shape_feather": 0.0
})
color = Color(0, 0, 1, 1)
animation_resources = Array[ExtResource("4_5ropb")]([SubResource("Resource_o1tfi")])
starting_material = SubResource("ShaderMaterial_jw3cb")

[node name="panel4" type="Panel" parent="."]
material = SubResource("ShaderMaterial_dqdnl")
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
pivot_offset = Vector2(20, 20)
theme_override_styles/panel = SubResource("StyleBoxFlat_fq0np")
script = ExtResource("1_ktjvc")
starting_values = Dictionary[String, Variant]({
"edges": 4,
"position": Vector2(0.5, 0.5),
"progress": 1.0,
"rotation_angle": 0.0,
"rotation_degrees": 0.0,
"shape_feather": 0.0
})
color = Color(1, 0, 1, 1)
animation_resources = Array[ExtResource("4_5ropb")]([SubResource("Resource_n8xfu")])
starting_material = SubResource("ShaderMaterial_dqdnl")
